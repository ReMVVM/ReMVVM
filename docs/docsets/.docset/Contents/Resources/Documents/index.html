<!DOCTYPE html>
<html lang="en">
  <head>
    <title>  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
    <script src="js/lunr.min.js" defer></script>
    <script src="js/typeahead.jquery.js" defer></script>
    <script src="js/jazzy.search.js" defer></script>
  </head>
  <body>
    <a title="  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html"> Docs</a> (89% documented)</p>
        <p class="header-right">
          <form role="search" action="search.json">
            <input type="text" placeholder="Search documentation" data-typeahead>
          </form>
        </p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html"> Reference</a>
        <img id="carat" src="img/carat.png" />
          Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a href="Classes.html">Classes</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Classes/CompositeViewModelFactory.html">CompositeViewModelFactory</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/InitializableViewModelFactory.html">InitializableViewModelFactory</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/Interceptor.html">Interceptor</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/MockSource.html">MockSource</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ReMVVMConfig.html">ReMVVMConfig</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/SingleViewModelFactory.html">SingleViewModelFactory</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/StateMapper.html">StateMapper</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/Store.html">Store</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/Store/StateWrapper.html">– StateWrapper</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/ViewModelProvider.html">ViewModelProvider</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Enums.html">Enumerations</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Enums/ComposedReducer.html">ComposedReducer</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/EmptyReducer.html">EmptyReducer</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/ReMVVM.html">ReMVVM</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/ReMVVM/Dispatcher.html">– Dispatcher</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/ReMVVM/State.html">– State</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/ReMVVM/ViewModel.html">– ViewModel</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Protocols.html">Protocols</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Protocols/AnyMiddleware.html">AnyMiddleware</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ConvertMiddleware.html">ConvertMiddleware</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/Dispatcher.html">Dispatcher</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/Initializable.html">Initializable</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/Middleware.html">Middleware</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/Reducer.html">Reducer</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/Source.html">Source</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/StateAssociated.html">StateAssociated</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/StateObserver.html">StateObserver</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/StateSource.html">StateSource</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols.html#/s:10ReMVVMCore11StoreActionP">StoreAction</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/StoreState.html">StoreState</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/ViewModelFactory.html">ViewModelFactory</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Typealiases.html">Type Aliases</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:10ReMVVMCore8AnyStorea">AnyStore</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:10ReMVVMCore23InterceptorNextFunctiona">InterceptorNextFunction</a>
              </li>
              <li class="nav-group-task">
                <a href="Typealiases.html#/s:10ReMVVMCore9ViewModela">ViewModel</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <p><a href="https://dgrzeszczak.github.io/ReMVVM"><img src="https://img.shields.io/badge/Documentation-geen" alt="Documentation"></a>
<a href="https://github.com/Carthage/Carthage"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat" alt="Carthage compatible"></a></p>
<h1 id='remvvm' class='heading'>ReMVVM</h1>

<p><em>ReMVVM</em> is an application architecture concept, marriage of <em>Unidirectional Data Flow</em> (<em>Redux</em>) with <em>MVVM</em>. </p>

<p>Redux + MVVM = ReMVVM </p>
<h1 id='motivation' class='heading'>Motivation</h1>

<p><strong>Model-View-ViewModel</strong> - is well known and widely used architecture on <em>iOS</em> platform. It is very simple, lightweight, doesn’t bring any boilerplate and works well with reactive programming (can be used without it of course). Working on the app which contain more than single view you will find couple of questions: </p>

<ul>
<li>who is responsible to create View Model ?</li>
<li>how to pass parameters to View Model’s constructor or fabric ?</li>
<li>how to implement switching to the new view ? Where to make view change and how to pass View Model to the View ?</li>
</ul>

<p>Of course you can find couple patterns to solve that such as coordinator but surprisingly easy you can follow the wrong path.</p>

<p><strong>Unidirectional Data Flow (UDF)</strong> - the main concept behind is immutable application state that can be changed only in one place in the app (<em>Store</em>) and only by predictable plain functions (in <em>Reducers</em>) ie. State + Action =  NewState. The most popular implementation of that concept is JavaScript library called <em>Redux</em>. The first and most popular swift’s implementation is <em>ReSwift</em> by Benjamin Encz. If you are not familiar with that architecture I strongly recommend to look on Benjamin’s <a href="https://academy.realm.io/posts/benji-encz-unidirectional-data-flow-swift/">presentation</a> and look into <a href="https://github.com/ReSwift/ReSwift">ReSwift</a> documentation. </p>

<p>You can find an easy example of <em>Redux</em> implementation with incrementing and decrementing single integer value. Let’s imagine you have application with 15-30 screens, all with complicated view structure and communication with backend API. It will bring complicated <em>Application State</em>, a lot of <em>Reducers</em> and dozens or even hundreds of <em>Actions</em> for the state changes. </p>

<p>But… what about making a mix of two architectures ? Can we implement “global” app state by <em>Unidirectional Data Flow</em> and use <em>MVVM</em> pattern for each screen in the app with all benefits it has ? We can and it is what <em>ReMVVM</em> was made for.</p>
<h1 id='components' class='heading'>Components</h1>

<p>For the simplicity, you can think that <em>Unidirectional Data Flow</em> part stores global data model state of the app. <em>View Model</em> may take that data, listens and reacts on the data change and of course converts and serves it for the <em>View</em> layer.</p>

<p>We can divide components on two groups related with <em>Unidirectional Data Flow</em> and <em>MVVM</em>. </p>

<p><img src="img/ReMVVM_architecture_components.png" alt=""> </p>
<h2 id='unidirectional-data-flow' class='heading'>Unidirectional Data Flow:</h2>

<p><strong><code><a href="Classes/Store.html">Store</a></code></strong> - contains your application state that can be modified only by dispatching an <code><a href="Protocols.html#/s:10ReMVVMCore11StoreActionP">StoreAction</a></code>. Every state change is notified to every <code><a href="Protocols/StateObserver.html">StateObserver</a></code>.</p>

<p><strong><code><a href="Protocols/StoreState.html">StoreState</a></code></strong> - it’s immutable data structure that holds your application data. In <em>ReMVVM</em> it has to provide <em><code><a href="Protocols/ViewModelFactory.html">ViewModelFactory</a></code></em> that will be used for creating View Models for your view(s).</p>

<p><strong><code><a href="Protocols.html#/s:10ReMVVMCore11StoreActionP">StoreAction</a></code></strong> - describes state change and is handled by corresponding <em><code><a href="Protocols/Reducer.html">Reducer</a></code></em>. </p>

<p><strong><code><a href="Protocols/Middleware.html">Middleware</a></code></strong> - mechanism for enhance action’s dispatch functionality. It is usually used to simplify asynchronous dispatch and implement ‘side effects’ if required.</p>

<p><strong><code><a href="Protocols/Reducer.html">Reducer</a></code></strong> - provides pure function that returns new state based on current state and the action. </p>
<h2 id='mvvm' class='heading'>MVVM:</h2>

<p><strong><code><a href="Typealiases.html#/s:10ReMVVMCore9ViewModela">ViewModel</a></code></strong> - is designed to store and manage UI related data for the view</p>

<p><strong><code><a href="Classes/ViewModelProvider.html">ViewModelProvider</a></code></strong> - provides View Model(s) using ViewModelFactory from current state</p>

<p><strong><code><a href="Protocols/ViewModelFactory.html">ViewModelFactory</a></code></strong> - creates View Model instances</p>
<h1 id='example' class='heading'>Example</h1>

<p>Let’s start with standard „The counter” example. We will implement one <em>View</em> that presents the counter value and two buttons to increase and decrease it. We will use <em>SwiftUI</em> and <em>Combine</em> but we can do it with <em>UIKit</em> with or without any other <em>Reactive</em> framework. </p>

<p>Counter value will be stored in application state in Store. View model will be listening on every change and will serve counter’s value as a string value. </p>

<p>It is extremely easy example. You may feel there is no need to put counter into application state or even there is no need to have view model and that’s true but usually in real life I&rsquo;m sure you will find the benefits. </p>

<p>First, we need to define our application state. We don’t need custom <code><a href="Protocols/ViewModelFactory.html">ViewModelFactory</a></code> so we will use default implementation of <code><a href="Protocols/StoreState.html">StoreState</a></code> protocol.</p>
<pre class="highlight swift"><code><span class="kd">struct</span> <span class="kt">ApplicationState</span><span class="p">:</span> <span class="kt">StoreState</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">counter</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>
</code></pre>

<p>Second, we need an <code><a href="Protocols.html#/s:10ReMVVMCore11StoreActionP">StoreAction</a></code> that will let us to change state. </p>
<pre class="highlight swift"><code><span class="kd">enum</span> <span class="kt">CounterAction</span><span class="p">:</span> <span class="kt">StoreAction</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">increase</span>
    <span class="k">case</span> <span class="n">decrease</span>
<span class="p">}</span>
</code></pre>

<p>Third, we need a <code><a href="Protocols/Reducer.html">Reducer</a></code> that will update counter value based on action.</p>
<pre class="highlight swift"><code><span class="kd">enum</span> <span class="kt">CounterReducer</span><span class="p">:</span> <span class="kt">Reducer</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">reduce</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">with</span> <span class="nv">action</span><span class="p">:</span> <span class="kt">CounterAction</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">action</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">increase</span><span class="p">:</span> <span class="k">return</span> <span class="n">state</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">decrease</span><span class="p">:</span> <span class="k">return</span> <span class="n">state</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>Then, we can write view model that observes state changes and served mapped value for the view. </p>
<pre class="highlight swift"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">CounterViewModel</span><span class="p">:</span> <span class="kt">ObservableObject</span><span class="p">,</span> <span class="kt">Initializable</span> <span class="p">{</span>

    <span class="kd">@Published</span> <span class="kd">private(set)</span> <span class="k">var</span> <span class="nv">counter</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>

    <span class="kd">@ReMVVM</span><span class="o">.</span><span class="kt">State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?</span>

    <span class="kd">required</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="err">$</span><span class="n">state</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="kt">String</span><span class="o">.</span><span class="kd">init</span><span class="p">)</span><span class="o">.</span><span class="nf">assign</span><span class="p">(</span><span class="nv">to</span><span class="p">:</span> <span class="o">&amp;</span><span class="err">$</span><span class="n">counter</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<details>
<summary>Without property wrappers</summary>
  
&ldquo;`swift
final class CounterViewModel: ObservableObject, Initializable, StateObserver {

    @Published private(set) var counter: String = &rdquo;&ldquo;

    required init() { }

    func didReduce(state: Int, oldState: Int?) {
        counter = String(state)
    }
}
&rdquo;`

*Please notice &ldquo;`StateObserver&rdquo;` declaration!*
</details>

<p>Finally, we can create our view.</p>
<pre class="highlight swift"><code><span class="kd">struct</span> <span class="kt">CounterView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>

    <span class="kd">@ReMVVM</span><span class="o">.</span><span class="kt">ViewModel</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="kt">CounterViewModel</span><span class="o">!</span>
    <span class="kd">@ReMVVM</span><span class="o">.</span><span class="kt">Dispatcher</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">dispatcher</span>

    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"Counter: </span><span class="se">\(</span><span class="n">viewModel</span><span class="o">.</span><span class="n">counter</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
                <span class="o">.</span><span class="nf">padding</span><span class="p">(</span><span class="o">.</span><span class="n">bottom</span><span class="p">)</span>

            <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="n">dispatcher</span><span class="p">[</span><span class="kt">CounterAction</span><span class="o">.</span><span class="n">increase</span><span class="p">])</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Increase"</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="n">dispatcher</span><span class="p">[</span><span class="kt">CounterAction</span><span class="o">.</span><span class="n">decrease</span><span class="p">])</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"Decrease"</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>Probably you’ve noticed that we wrote <code><a href="Protocols/Reducer.html">Reducer</a></code> for the counter value and view model listens for Int type values instead of the <code>ApplicationState</code>. We could base on <code>ApplicationState</code> but I would like to present you idea about substates. </p>

<p>It’s good to separate data as much as possible so we can operate on smaller chunks, so then view model depends only on the required data not the whole state. </p>

<p>To accomplish that we still need to create <code><a href="Protocols/Reducer.html">Reducer</a></code> for <code>ApplicationState</code>. </p>
<pre class="highlight swift"><code><span class="kd">struct</span> <span class="kt">ApplicationReducer</span><span class="p">:</span> <span class="kt">Reducer</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">reduce</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="kt">ApplicationState</span><span class="p">,</span> <span class="n">with</span> <span class="nv">action</span><span class="p">:</span> <span class="kt">StoreAction</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">ApplicationState</span> <span class="p">{</span>
        <span class="kt">ApplicationState</span><span class="p">(</span>
            <span class="nv">counter</span><span class="p">:</span> <span class="kt">CounterReducer</span><span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="o">.</span><span class="n">counter</span><span class="p">,</span> <span class="nv">with</span><span class="p">:</span> <span class="n">action</span><span class="p">)</span>
            <span class="c1">//...</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>We also need to provide <code><a href="Classes/StateMapper.html">StateMapper</a></code> that converts <code>ApplicationState</code> to our <code>Int</code> substate. Thanks to this we can observe substate changes in view model.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">counterMapper</span> <span class="o">=</span> <span class="kt">StateMapper</span><span class="o">&lt;</span><span class="kt">ApplicationState</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="p">\</span><span class="o">.</span><span class="n">counter</span><span class="p">)</span>
</code></pre>

<p>Now, we can initialise store.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">initialState</span> <span class="o">=</span> <span class="kt">ApplicationState</span><span class="p">(</span><span class="nv">counter</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">store</span> <span class="o">=</span> <span class="kt">Store</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">initialState</span><span class="p">,</span>
                  <span class="nv">reducer</span><span class="p">:</span> <span class="kt">ApplicationReducer</span><span class="o">.</span><span class="k">self</span><span class="p">,</span>
                  <span class="nv">stateMappers</span><span class="p">:</span> <span class="p">[</span><span class="n">counterMapper</span><span class="p">])</span>
<span class="kt">ReMVVM</span><span class="o">.</span><span class="nf">initialize</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">store</span><span class="p">)</span>
</code></pre>

<p>And test it</p>

<p><img src="img/CounterViewPreview.gif" alt=""> </p>

<details>
  <summary>Testing substate reducer</summary>
  
  ![](img/CounterViewPreview2.gif) 

</details>
<h1 id='remvvmcore-and-remvvmswiftui' class='heading'>ReMVVMCore and ReMVVMSwiftUI</h1>

<p>ReMVVM project contains two targets: </p>

<ul>
<li>ReMVVMCore - contains ReMVVM implementation plus &lsquo;basic versions&rsquo; of property wrappers that you can use with UIKit<br></li>
<li>ReMVVMSwiftUI - contains property wrappers that should be used with SwiftUI conjunction<br></li>
</ul>

<p>Basically import ReMVVMSwiftUI when using SwiftUI, import ReMVVMCore otherwise.</p>
<h1 id='extensions' class='heading'>Extensions</h1>

<p>Sneak peak for navigation implemented with ReMVVM. </p>

<p><code>CounterView</code> has no navigation logic added. The view contains couple additional buttons that only send appropriete actions.</p>

<p><img src="img/NavigationTest.gif" alt=""> </p>

<details>
  <summary>Details</summary>
  
Code:
  
&ldquo;`swift
struct CounterView: View {

    @ReMVVM.ViewModel private var viewModel: CounterViewModel!
    @ReMVVM.Dispatcher private var dispatcher

    var body: some View {
        VStack {
            VStack {
                Text(&quot;View id: \(viewModel.id)&rdquo;)
                Text(&ldquo;Counter: \(viewModel.counter)&rdquo;)

                Button(action: dispatcher[CounterAction.increase]) {
                    Text(&ldquo;Increase&rdquo;)
                }
                Button(action: dispatcher[CounterAction.decrease]) {
                    Text(&ldquo;Decrease&rdquo;)
                }
            }.padding(.bottom)

            VStack {
                Text(&ldquo;Navigation: -> new CounterView&rdquo;)
                Button(action: dispatcher[Push(with: CounterView())]) {
                    Text(&ldquo;Push new&rdquo;)
                }
                Button(action: dispatcher[Pop()]) {
                    Text(&ldquo;Pop&rdquo;)
                }
                Button(action: dispatcher[ShowModal(view: CounterView())]) {
                    Text(&ldquo;Show new on modal&rdquo;)
                }
                Button(action: dispatcher[ShowModal(view: CounterView(), navigation: true)]) {
                    Text(&ldquo;Show new on modal with nav&rdquo;)
                }
                Button(action: dispatcher[DismissModal()]) {
                    Text(&ldquo;Dismiss modal&rdquo;)
                }
                Button(action: dispatcher[Show(on: Navigation.root, view: CounterView())]) {
                    Text(&ldquo;Show new on root&rdquo;)
                }
                Button(action: dispatcher[NavigationTab.profile.action]) {
                    Text(&ldquo;Show profile tab&rdquo;)
                }
            }
        }
    }
}
&ldquo;`

For the example code please have a look here: [ReMVVMSampleSwiftUI](https://github.com/ReMVVM/ReMVVMSampleSwiftUI)

We are working on extensions to handle navigation in the app on separate projects within ReMVVM repository. 

[ReMVVMExtUIKit](https://github.com/ReMVVM/ReMVVMExtUIKit) is used in couple live applications available in AppStore. 

[ReMVVMExtSwiftUI](https://github.com/ReMVVM/ReMVVMExtSwiftUI) is a concept that prooves that it is possible to build navigation mechanism in pure SwiftUI. 
 
</details>
<h1 id='summary' class='heading'>Summary</h1>

<p><em>ReMVVM</em> architecture brings great separation between layers. It&rsquo;s clear where to store model data, who and where creates view model and how it&rsquo;s passed to the view. It takes the biggest advantages of two different architectures and makes the code readable without introducing any boilerplate.</p>

          </section>
        </section>
        <section id="footer">
          <p>&copy; 2021 <a class="link" href="" target="_blank" rel="noopener" rel="external"></a>. All rights reserved. (Last updated: 2021-09-13)</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="noopener" rel="external">jazzy ♪♫ v0.14.0</a>, a <a class="link" href="https://realm.io" target="_blank" rel="noopener" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
